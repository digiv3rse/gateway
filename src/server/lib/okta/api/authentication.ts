import { buildUrl } from '@/shared/lib/routeUtils';
import { fetch } from '@/server/lib/fetch';
import { joinUrl } from '@guardian/libs';
import {
  authorizationHeader,
  defaultHeaders,
} from '@/server/lib/okta/api/headers';
import { getConfiguration } from '@/server/lib/getConfiguration';
import { Response } from 'node-fetch';
import { handleErrorResponse } from '@/server/lib/okta/api/errors';
import { OktaError } from '@/server/models/okta/Error';
import {
  AuthenticationRequestParameters,
  AuthenticationTransaction,
} from '@/server/models/okta/Authentication';
import { handleVoidResponse } from '@/server/lib/okta/api/responses';

const { okta } = getConfiguration();

/**
 * Okta's Authentication API
 * https://developer.okta.com/docs/reference/api/authn/
 */

/**
 * @name authenticate
 * @description Primary Authentication with Public Application
 *
 * The authentication endpoint takes a number of different parameters, which are documented here: https://developer.okta.com/docs/reference/api/authn/#request-parameters-for-primary-authentication
 *
 * Which parameters to provide depends on the context of use.
 *
 * For example for sign in with email/username and password, you would only provide:
 * @param {string} body.username User's short-name (for example: dade.murphy) or unique fully-qualified sign in name/email (for example: dade.murphy@example.com)
 * @param {string} body.password User's password credential
 *
 * Whereas in other cases, for example when activating a user with a token, you would provide:
 * @param {string} body.token Token received as part of activation user request. This token is emailed to the user when they register, and can be (re)generated by calling the activate or reactivate endpoints in the Users API
 * see [src/server/lib/okta/api/users.ts](users.ts)
 *
 * @returns Promise<AuthenticationTransaction>
 */
export const authenticate = async (
  body: AuthenticationRequestParameters,
): Promise<AuthenticationTransaction> => {
  const path = buildUrl('/api/v1/authn');
  return await fetch(joinUrl(okta.orgUrl, path), {
    method: 'POST',
    body: JSON.stringify(body),
    headers: defaultHeaders,
  }).then(handleAuthenticationResponse);
};

/**
 * @name sendForgotPasswordEmail
 * @description Starts a new forgot password process by sending a reset password email
 *
 * https://developer.okta.com/docs/reference/api/authn/#forgot-password-with-email-factor
 *
 * There are two ways to use this endpoint:
 * 1. without an API token - this starts a self-service forgotten password flow. The user is still
 * ACTIVE and can still sign-in without resetting their password. This is the flow we are using.
 * 2. with an API token - this becomes an administrator-initiated reset password flow which
 * puts the user into the RECOVERY state. This prevents them from signing in until they have
 * completed the recovery action and set a new password
 *
 * @param {string} username User's short-name (for example: dade.murphy) or unique fully-qualified sign in
 * name (for example: dade.murphy@example.com)
 *
 * @returns Promise<void>
 */
export const sendForgotPasswordEmail = async (
  username: string,
): Promise<void> => {
  const path = buildUrl('/api/v1/authn/recovery/password');
  const body = {
    username,
    factorType: 'EMAIL',
  };
  return await fetch(joinUrl(okta.orgUrl, path), {
    method: 'POST',
    body: JSON.stringify(body),
    // do not add authorization headers here as this turns the operation
    // into an administrator action and locks the user out of their account
    headers: defaultHeaders,
  }).then(handleVoidResponse);
};

/**
 * @name validateRecoveryToken
 * @description Validates a recovery token that was distributed to the end user
 *
 * https://developer.okta.com/docs/reference/api/authn/#verify-recovery-token
 *
 * This is used to continue a recovery transaction (such as
 * resetting a password or completing account activation).
 *
 * If valid, a state token is returned which can be used to complete the recovery transaction.
 *
 * @param {string} body.recoveryToken Recovery token that was distributed to the end user via out-of-band mechanism such as email
 *
 * @returns Promise<AuthenticationTransaction>
 */
export const validateRecoveryToken = async (body: {
  recoveryToken: string;
}): Promise<AuthenticationTransaction> => {
  const path = buildUrl('/api/v1/authn/recovery/token');
  return await fetch(joinUrl(okta.orgUrl, path), {
    method: 'POST',
    body: JSON.stringify(body),
    headers: defaultHeaders,
  }).then(handleAuthenticationResponse);
};

/**
 * @name resetPassword
 * @description Completes a password reset transaction
 *
 * https://developer.okta.com/docs/reference/api/authn/#reset-password
 *
 * @param {string} body.stateToken State token for the current transaction. State tokens can be obtained by starting a forgotten
 * password flow or admin-initiated reset password flow or by passing an activation token into the /authn endpoint
 * @param {string} body.newPassword User's new password
 *
 * @returns Promise<AuthenticationTransaction>
 */
export const resetPassword = async (body: {
  stateToken: string;
  newPassword: string;
}): Promise<AuthenticationTransaction> => {
  const path = buildUrl('/api/v1/authn/credentials/reset_password');
  return await fetch(joinUrl(okta.orgUrl, path), {
    method: 'POST',
    body: JSON.stringify(body),
    headers: { ...defaultHeaders, ...authorizationHeader() },
  }).then(handleAuthenticationResponse);
};

/**
 * @name handleAuthenticationResponse
 * @description Handles the response from Okta's /authn endpoint
 * and converts it to a AuthenticationTransaction object
 * @param response node-fetch response object
 * @returns Promise<AuthenticationTransaction>
 */
const handleAuthenticationResponse = async (
  response: Response,
): Promise<AuthenticationTransaction> => {
  if (response.ok) {
    try {
      return await response.json().then((json) => {
        const token = json as AuthenticationTransaction;
        return {
          stateToken: token.stateToken,
          sessionToken: token.sessionToken,
          expiresAt: token.expiresAt,
          _embedded: token._embedded,
        };
      });
    } catch (error) {
      throw new OktaError({
        message: 'Could not parse Okta authentication transaction response',
      });
    }
  } else {
    return await handleErrorResponse(response);
  }
};
